<?php
namespace Synapse\ReportsBundle\Repository;

use Doctrine\DBAL\Connection;
use JMS\DiExtraBundle\Annotation as DI;
use Monolog\Logger;
use Symfony\Component\Validator\Constraints\Date;
use Synapse\CoreBundle\Exception\SynapseDatabaseException;
use Synapse\CoreBundle\Repository\SynapseRepository;
use Synapse\CoreBundle\Util\Constants\StudentConstant;
use Synapse\ReportsBundle\Entity\Reports;
use Synapse\RestBundle\Exception\ValidationException;

class ReportsRepository extends SynapseRepository
{
    const REPOSITORY_KEY = 'SynapseReportsBundle:Reports';

    /**
     * @DI\Inject("logger")
     */
    private $logger;


    /**
     * Finds an entity by its primary key / identifier.
     *
     * @param mixed $id The identifier.
     * @param int|null $lockMode One of the \Doctrine\DBAL\LockMode::* constants
     *                              or NULL if no specific lock mode should be used
     *                              during the search.
     * @param int|null $lockVersion The lock version.
     *
     * @return Reports|null The entity instance or NULL if the entity can not be found.
     */
    public function find($id, $lockMode = null, $lockVersion = null)
    {
        return parent::find($id, $lockMode, $lockVersion); // TODO: Change the autogenerated stub
    }


    /**
     * Finds entities by a set of criteria.
     *
     * @param array $criteria
     * @param array|null $orderBy
     * @param int|null $limit
     * @param int|null $offset
     *
     * @return Reports[]
     */
    public function findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
    {
        return parent::findBy($criteria, $orderBy, $limit, $offset); // TODO: Change the autogenerated stub
    }


    /**
     * Finds a single entity by a set of criteria.
     *
     * @param array $criteria
     * @param array|null $orderBy
     *
     * @return Reports|null The entity instance or NULL if the entity can not be found.
     */
    public function findOneBy(array $criteria, array $orderBy = null)
    {
        return parent::findOneBy($criteria, $orderBy); // TODO: Change the autogenerated stub
    }


    /**
     *
     * @param Reports $Reports
     * @return Reports
     */
    public function create(Reports $Reports)
    {
        $em = $this->getEntityManager();
        $em->persist($Reports);
        return $Reports;
    }

    /**
     *
     * @param Reports $Reports
     */
    public function remove(Reports $Reports)
    {
        $em = $this->getEntityManager();
        $em->remove($Reports);
    }


    /**
     * Getting activity details for csv export for a faculty
     *
     * @param integer $orgId
     * @param string $yearStartDate
     * @param string $yearEndDate
     * @param string $type
     * @param array $participantStudents
     * @param null|integer $accessPersonId
     * @param integer $loggedInUserId
     * @param array $sharingAccess
     * @return array
     */
    public function getCampusActvityDetails($orgId, $yearStartDate, $yearEndDate, $type, $participantStudents, $accessPersonId = NULL, $loggedInUserId, $sharingAccess)
    {

        $em = $this->getEntityManager();
        $rfacultyAccess = '';
        $cfacultyAccess = '';
        $nfacultyAccess = '';
        $afacultyAccess = '';
        $rAddYear = '';
        $cAddYear = '';
        $nAddYear = '';
        $aAddYear = '';
        $eAddYear = '';

        //Permission Fix

        $permArr = array(
            StudentConstant::NOTE_TEAM_ACCESS => $sharingAccess[StudentConstant::NOTES][StudentConstant::TEAM_VIEW],
            'notePublicAccess' => $sharingAccess[StudentConstant::NOTES][StudentConstant::PUBLIC_VIEW],
            'contactTeamAccess' => $sharingAccess[StudentConstant::LOG_CONTACTS][StudentConstant::TEAM_VIEW],
            'contactPublicAccess' => $sharingAccess[StudentConstant::LOG_CONTACTS][StudentConstant::PUBLIC_VIEW],
            'referralTeamAccess' => $sharingAccess[StudentConstant::REFERRALS][StudentConstant::TEAM_VIEW],
            'referralPublicAccess' => $sharingAccess[StudentConstant::REFERRALS][StudentConstant::PUBLIC_VIEW],
            'referralPublicAccessReasonRouted' => $sharingAccess['Referrals Reason Routed'][StudentConstant::PUBLIC_VIEW],
            'referralTeamAccessReasonRouted' => $sharingAccess['Referrals Reason Routed'][StudentConstant::TEAM_VIEW],
            'appointmentTeamAccess' => $sharingAccess[StudentConstant::BOOKING][StudentConstant::TEAM_VIEW],
            'appointmentPublicAccess' => $sharingAccess[StudentConstant::BOOKING][StudentConstant::PUBLIC_VIEW],
            'emailTeamAccess' => $sharingAccess[StudentConstant::EMAIL][StudentConstant::TEAM_VIEW],
            'emailPublicAccess' => $sharingAccess[StudentConstant::EMAIL][StudentConstant::PUBLIC_VIEW]
        );

        $referralTeamAccess = $sharingAccess['Referrals']['team_view'];
        $referralPublicAccess = $sharingAccess['Referrals']['public_view'];
        $referralPublicAccessReasonRouted = $permArr['referralPublicAccessReasonRouted'];
        $referralTeamAccessReasonRouted = $permArr['referralTeamAccessReasonRouted'];

        $noteTeamAccess = (int)$permArr[StudentConstant::NOTE_TEAM_ACCESS];
        $notePublicAccess = (int)$permArr['notePublicAccess'];

        $contactTeamAccess = (int)$permArr['contactTeamAccess'];
        $contactPublicAccess = (int)$permArr['contactPublicAccess'];

        $appointmentTeamAccess = (int)$permArr['appointmentTeamAccess'];
        $appointmentPublicAccess = $permArr['appointmentPublicAccess'];

        $emailTeamAccess = (int)$permArr['emailTeamAccess'];
        $emailPublicAccess = (int)$permArr['emailPublicAccess'];

        //End of getting permission

        if ($yearStartDate != NULL || $yearEndDate != NULL) {
            $rAddYear = " and (R.created_at between  :yearStartDate and  :yearEndDate )";
            $cAddYear = " and (C.contact_date between :yearStartDate and  :yearEndDate )";
            $nAddYear = " and (N.created_at between :yearStartDate and  :yearEndDate )";
            $aAddYear = " and (A.start_date_time between :yearStartDate and  :yearEndDate )";
            $eAddYear = " and (E.created_at between :yearStartDate and  :yearEndDate )";
        }
        if ($accessPersonId != '') {
            $rfacultyAccess = ' and R.person_id_faculty = :accessPersonId';
            $cfacultyAccess = ' and C.person_id_faculty = :accessPersonId';
            $nfacultyAccess = ' and N.person_id_faculty = :accessPersonId';
            $afacultyAccess = ' and A.person_id = :accessPersonId';
            $efacultyAccess = ' and E.person_id_faculty = :accessPersonId';
        }
        $tempsql = array();

        $tempsql['referrals'] = "SELECT
        R.id AS activity_id,
        PS.external_id as external_id,
        PS.username as email,
        PS.id as student_id,
        acl.description as reason,
        '' as contact_type,
        PS.firstname as student_firstname,
        PS.lastname as student_lastname,
        P.firstname AS faculty_firstname,
        P.lastname AS faculty_lastname,
        CONCAT_WS(' ',assignedperson.firstname, assignedperson.lastname) as assignedpersonname,
        R.note AS details,
        'Referral' as activity_type,
        R.status as activity_status,
        R.created_at,
        R.access_private,
        R.access_public,
        R.access_team ,
        '' as has_attended,
        GROUP_CONCAT( IF(intparty.firstname IS NULL AND intparty.lastname IS NULL, NULL,
        CONCAT_WS(' ',intparty.firstname, intparty.lastname)
        ) ORDER BY IF(intparty.firstname IS NULL AND intparty.lastname IS NULL, NULL,
        CONCAT_WS(' ',intparty.firstname, intparty.lastname)) ASC SEPARATOR ',') as interested_parties
        FROM activity_log AS AL
        LEFT JOIN referrals AS R ON AL.referrals_id = R.id
        LEFT JOIN person AS P ON R.person_id_faculty = P.id
        LEFT JOIN     person AS PS on PS.id = R.person_id_student
        left join person as assignedperson on (assignedperson.id = R.person_id_assigned_to)
        left join referrals_interested_parties as rip on rip.referrals_id = R.id
        left join person as intparty on (intparty.id = rip.person_id)
        left join activity_category as ac on (ac.id = R.activity_category_id)
        left join activity_category_lang as acl on (acl.activity_category_id = ac.id)
        LEFT JOIN referrals_teams AS RT ON R.id = RT.referrals_id
        LEFT JOIN related_activities as RA ON R.id = RA.referral_id
        LEFT JOIN activity_log AL1 ON RA.activity_log_id = AL1.id
        LEFT JOIN referrals AS R1 ON AL1.referrals_id = R1.id
        WHERE R.organization_id = :orgId AND R.status in ('O','C') AND R.person_id_student in (SELECT DISTINCT merged.student_id
        FROM
        (
        SELECT S.person_id AS student_id,
        F.org_permissionset_id AS permissionset_id
        FROM org_group_students AS S
        INNER JOIN org_group_tree ogt ON S.org_group_id = ogt.descendant_group_id
        AND ogt.deleted_at IS NULL
        INNER JOIN org_group_faculty F ON F.org_group_id = ogt.ancestor_group_id
        AND ogt.deleted_at IS NULL AND F.deleted_at is null
        WHERE S.deleted_at is null  AND F.person_id= :loggedInUserId 
        UNION ALL 
        SELECT S.person_id AS student_id,
        F.org_permissionset_id AS permissionset_id
        FROM org_course_student AS S
        INNER JOIN org_courses AS C ON C.id = S.org_courses_id AND C.deleted_at is null
        INNER JOIN org_course_faculty AS F ON F.org_courses_id = S.org_courses_id AND F.deleted_at is null
        INNER JOIN org_academic_terms AS OAT ON OAT.id = C.org_academic_terms_id  AND OAT.end_date >= now() AND OAT.deleted_at is null
        WHERE S.deleted_at is null  AND F.person_id= :loggedInUserId 
        ) AS merged
        INNER JOIN org_person_student AS P ON P.person_id=merged.student_id AND P.deleted_at IS NULL AND P.organization_id = :orgId
        INNER JOIN org_permissionset OPS ON merged.permissionset_id = OPS.id AND OPS.accesslevel_ind_agg = 1)
        AND R.deleted_at IS NULL AND (
        CASE WHEN AL1.activity_type IS NOT NULL AND ( AL1.activity_type = 'R' AND R1.access_private = 1) THEN R.person_id_faculty = :loggedInUserId ELSE
    
    
    
        CASE WHEN R.access_team = 1 THEN
    
        (
        RT.teams_id IN
        (SELECT teams_id FROM team_members WHERE person_id = :loggedInUserId AND teams_id IN (SELECT teams_id from referrals_teams WHERE referrals_id = R.id AND deleted_at IS NULL))
    
        AND
    
        (([referralTeamAccess] = 1
            and R.is_reason_routed = 0)
            OR ([referralTeamAccessReasonRouted] = 1
            and R.is_reason_routed = 1))
    
        )
    
            ELSE
            CASE WHEN R.access_private = 1 THEN R.person_id_faculty = :loggedInUserId
            ELSE
            (
            R.access_public = 1
            AND
            ((([referralPublicAccess] = 1
            and R.is_reason_routed = 0)
            OR ([referralPublicAccessReasonRouted] = 1
            and R.is_reason_routed = 1))
            OR R.person_id_faculty = :loggedInUserId)
        )
    
            END END END ) $rAddYear $rfacultyAccess GROUP BY R.id
    
             
            union
    
            SELECT
            R.id AS activity_id,
            PS.external_id as external_id,
            PS.username as email,
            PS.id as student_id,
            acl.description as reason,
            '' as contact_type,
            PS.firstname as student_firstname,
            PS.lastname as student_lastname,
            P.firstname AS faculty_firstname,
            P.lastname AS faculty_lastname,
            CONCAT_WS(' ',assignedperson.firstname, assignedperson.lastname) as assignedpersonname,
            R.note AS details,
            'Referral' as activity_type,
            R.status as activity_status,
            R.created_at,
            R.access_private,
            R.access_public,
            R.access_team ,
            '' as has_attended,
            GROUP_CONCAT( IF(intparty.firstname IS NULL AND intparty.lastname IS NULL, NULL,
            CONCAT_WS(' ',intparty.firstname, intparty.lastname)
        ) ORDER BY IF(intparty.firstname IS NULL AND intparty.lastname IS NULL, NULL,
            CONCAT_WS(' ',intparty.firstname, intparty.lastname)) ASC SEPARATOR ',') as interested_parties
            FROM referrals_interested_parties AS rip
            LEFT JOIN referrals AS R ON rip.referrals_id = R.id
            LEFT JOIN person AS P ON R.person_id_faculty = P.id
            LEFT JOIN     person AS PS on PS.id = R.person_id_student
            left join person as assignedperson on (assignedperson.id = R.person_id_assigned_to)
            left join person as intparty on (intparty.id = rip.person_id)
            left join activity_category as ac on (ac.id = R.activity_category_id)
            left join activity_category_lang as acl on (acl.activity_category_id = ac.id)
            LEFT JOIN referrals_teams AS RT ON R.id = RT.referrals_id
            LEFT JOIN related_activities as RA ON R.id = RA.referral_id
            LEFT JOIN activity_log AL1 ON RA.activity_log_id = AL1.id
            LEFT JOIN referrals AS R1 ON AL1.referrals_id = R1.id
            WHERE R.organization_id = :orgId AND R.status in ('O','C')
    
            AND
            CASE WHEN R.access_team = 1 THEN
    
            (
            RT.teams_id IN
            (SELECT teams_id FROM team_members WHERE person_id = :loggedInUserId AND teams_id IN (SELECT teams_id from referrals_teams WHERE referrals_id = R.id AND deleted_at IS NULL))
    
            AND
    
            (([referralTeamAccess] = 1
            and R.is_reason_routed = 0)
            OR ([referralTeamAccessReasonRouted] = 1
            and R.is_reason_routed = 1))
    
        )
    
            ELSE
            CASE WHEN R.access_private = 1 THEN R.person_id_faculty = :loggedInUserId
            ELSE
            ((
            R.access_public = 1
            AND
            (([referralPublicAccess] = 1
            and R.is_reason_routed = 0)
            OR ([referralPublicAccessReasonRouted] = 1
            and R.is_reason_routed = 1))
        )
            OR R.person_id_faculty = :loggedInUserId)
    
    
            END END
    
    
            AND R.deleted_at IS NULL
            AND rip.deleted_at IS NULL
            and P.deleted_at IS NULL
            AND rip.person_id  = :loggedInUserId
            $rAddYear $rfacultyAccess GROUP BY R.id
            ";

        $tempsql['contact'] = " SELECT
            C.id AS activity_id,
            PS.external_id as external_id,
            PS.username as email,
            PS.id as student_id,
            acl.description as reason,
            ctl.description as contact_type,
            PS.firstname as student_firstname,
            PS.lastname as student_lastname,
            P.firstname AS faculty_firstname,
            P.lastname AS faculty_lastname,
            '' as assignedpersonname,
            C.note AS details,
            'Contact' as activity_type,
            '' as activity_status,
            C.contact_date AS created_at,
            C.access_private,
            C.access_public,
            C.access_team ,
            '' as has_attended,
            '' as interested_parties
            FROM activity_log AS AL
            LEFT JOIN contacts AS C ON AL.contacts_id = C.id
            LEFT JOIN person AS P ON C.person_id_faculty = P.id
            LEFT JOIN person AS PS on PS.id = C.person_id_student
            LEFT JOIN contacts_teams AS CT ON C.id = CT.contacts_id
            left join contact_types as cty on (cty.id = C.contact_types_id)
            left join contact_types_lang as ctl on (ctl.contact_types_id = cty.id)
            left join activity_category as ac on (ac.id = C.activity_category_id)
            left join activity_category_lang as acl on (acl.activity_category_id = ac.id)
            LEFT JOIN related_activities as RA ON C.id = RA.contacts_id
            LEFT JOIN activity_log AL1 ON RA.activity_log_id = AL1.id
            LEFT JOIN contacts AS C1 ON AL1.contacts_id = C1.id
            WHERE C.person_id_student in (SELECT DISTINCT merged.student_id
            FROM
            (
            SELECT S.person_id AS student_id,
            F.org_permissionset_id AS permissionset_id
            FROM org_group_students AS S
            INNER JOIN org_group_tree ogt ON S.org_group_id = ogt.descendant_group_id
            AND ogt.deleted_at IS NULL
            INNER JOIN org_group_faculty F ON F.org_group_id = ogt.ancestor_group_id
            AND ogt.deleted_at IS NULL AND F.deleted_at is null
            WHERE S.deleted_at is null  AND F.person_id= :loggedInUserId
            UNION ALL 
            SELECT S.person_id AS student_id,
            F.org_permissionset_id AS permissionset_id
            FROM org_course_student AS S
            INNER JOIN org_courses AS C ON C.id = S.org_courses_id AND C.deleted_at is null
            INNER JOIN org_course_faculty AS F ON F.org_courses_id = S.org_courses_id AND F.deleted_at is null
            INNER JOIN org_academic_terms AS OAT ON OAT.id = C.org_academic_terms_id  AND OAT.end_date >= now() AND OAT.deleted_at is null
            WHERE S.deleted_at is null  AND F.person_id= :loggedInUserId 
        ) AS merged
        INNER JOIN org_person_student AS P ON P.person_id=merged.student_id AND P.deleted_at IS NULL AND P.organization_id = :orgId
        INNER JOIN org_permissionset OPS ON merged.permissionset_id = OPS.id AND OPS.accesslevel_ind_agg = 1)
        AND AL.deleted_at IS NULL AND C.deleted_at IS NULL AND C.organization_id = :orgId AND (
        CASE WHEN AL1.activity_type IS NOT NULL AND  (AL1.activity_type = 'C' AND C1.access_private = 1)  THEN C.person_id_faculty = :loggedInUserId ELSE
        CASE WHEN C.access_team = 1 THEN CT.teams_id IN (SELECT teams_id FROM team_members WHERE person_id = :loggedInUserId AND teams_id IN (SELECT teams_id from contacts_teams WHERE contacts_id = C.id AND deleted_at IS NULL)) AND  :contactTeamAccess = 1 ELSE
        CASE WHEN C.access_private = 1 THEN C.person_id_faculty = :loggedInUserId ELSE ((C.access_public = 1 AND :contactPublicAccess  = 1) OR C.person_id_faculty = :loggedInUserId)  END END END ) $cAddYear $cfacultyAccess Group by C.id
        ";

        $tempsql['note'] = " SELECT
        N.id AS activity_id,
        PS.external_id as external_id,
        PS.username as email,
        PS.id as student_id,
        acl.description as reason,
        '' as contact_type,
        PS.firstname as student_firstname,
        PS.lastname as student_lastname,
        P.firstname AS faculty_firstname,
        P.lastname AS faculty_lastname,
        '' as assignedpersonname,
        N.note AS details,
        'Note' as activity_type,
        '' as activity_status,
        N.note_date AS created_at,
        N.access_private,
        N.access_public,
        N.access_team ,
        '' as has_attended,
        '' as interested_parties
        FROM     activity_log AS AL
        LEFT JOIN     note AS N ON AL.note_id = N.id
        LEFT JOIN     person AS P ON N.person_id_faculty = P.id
        LEFT JOIN     person AS PS on PS.id = N.person_id_student
        LEFT JOIN     note_teams AS NT ON N.id = NT.note_id
        LEFT JOIN     related_activities AS RA ON N.id = RA.note_id
        left join activity_category as ac on (ac.id = N.activity_category_id)
        left join activity_category_lang as acl on (acl.activity_category_id = ac.id)
        LEFT JOIN     activity_log AL1 ON RA.activity_log_id = AL1.id
        LEFT JOIN     note AS N1 ON AL1.note_id = N1.id
        WHERE     AL.person_id_student in (SELECT DISTINCT merged.student_id
        FROM
        (
        SELECT S.person_id AS student_id,
        F.org_permissionset_id AS permissionset_id
        FROM org_group_students AS S
        INNER JOIN org_group_tree ogt ON S.org_group_id = ogt.descendant_group_id
        AND ogt.deleted_at IS NULL
        INNER JOIN org_group_faculty F ON F.org_group_id = ogt.ancestor_group_id
        AND ogt.deleted_at IS NULL AND F.deleted_at is null
        WHERE S.deleted_at is null  AND F.person_id= :loggedInUserId 
        UNION ALL 
        SELECT S.person_id AS student_id,
        F.org_permissionset_id AS permissionset_id
        FROM org_course_student AS S
        INNER JOIN org_courses AS C ON C.id = S.org_courses_id AND C.deleted_at is null
        INNER JOIN org_course_faculty AS F ON F.org_courses_id = S.org_courses_id AND F.deleted_at is null
        INNER JOIN org_academic_terms AS OAT ON OAT.id = C.org_academic_terms_id  AND OAT.end_date >= now() AND OAT.deleted_at is null
        WHERE S.deleted_at is null  AND F.person_id= :loggedInUserId 
        ) AS merged
        INNER JOIN org_person_student AS P ON P.person_id=merged.student_id AND P.deleted_at IS NULL AND P.organization_id = :orgId
        INNER JOIN org_permissionset OPS ON merged.permissionset_id = OPS.id AND OPS.accesslevel_ind_agg = 1)
        AND AL.deleted_at IS NULL  AND N.deleted_at IS NULL AND N.organization_id = :orgId AND (
        CASE  WHEN      AL1.activity_type IS NOT NULL   AND ( AL1.activity_type = 'N'   AND N.access_private = 1)  THEN      N.person_id_faculty = :loggedInUserId  ELSE CASE      WHEN   N.access_team = 1      THEN   NT.teams_id IN (SELECT     teams_id       FROM    team_members       WHERE    person_id = :loggedInUserId AND teams_id IN (SELECT      teams_id FROM     note_teams WHERE     note_id = N.id AND deleted_at IS NULL)) AND :noteTeamAccess  = 1  ELSE CASE   WHEN N.access_private = 1 THEN N.person_id_faculty = :loggedInUserId   ELSE ((N.access_public = 1 AND :notePublicAccess = 1) OR N.person_id_faculty = :loggedInUserId) END  END     END ) $nAddYear $nfacultyAccess GROUP BY N.id ";

        $tempsql['appointment'] = " SELECT
        A.id AS activity_id,
        PS.external_id as external_id,
        PS.username as email,
        PS.id as student_id,
        acl.description as reason,
        '' as contact_type,
        PS.firstname as student_firstname,
        PS.lastname as student_lastname,
        P.firstname AS faculty_firstname,
        P.lastname AS faculty_lastname,
        '' as assignedpersonname,
        A.description AS details,
        'Appointment' as activity_type,
        '' as activity_status,
        A.start_date_time AS created_at,
        A.access_private,
        A.access_public,
        A.access_team ,
        ARS.has_attended as has_attended,
        '' as interested_parties
        FROM     activity_log AL
        LEFT JOIN    appointment_recepient_and_status ARS ON (AL.appointments_id = ARS.appointments_id)        AND (ARS.deleted_at IS NULL)
        LEFT JOIN    Appointments A ON (ARS.appointments_id = A.id)        AND (A.deleted_at IS NULL)
        LEFT JOIN     appointments_teams as APT ON A.id = APT.appointments_id
        LEFT JOIN     person AS P ON ARS.person_id_faculty = P.id
        LEFT JOIN     person AS PS on PS.id = ARS.person_id_student
        LEFT JOIN     related_activities AS RA ON A.id = RA.appointment_id
        left join activity_category as ac on (ac.id = A.activity_category_id)
        left join activity_category_lang as acl on (acl.activity_category_id = ac.id)
        LEFT JOIN     activity_log AL1 ON RA.activity_log_id = AL1.id
        LEFT JOIN     Appointments AS A1 ON AL1.note_id = A1.id
        WHERE
        (AL.person_id_student in (SELECT DISTINCT merged.student_id
        FROM
        (
        SELECT S.person_id AS student_id,
        F.org_permissionset_id AS permissionset_id
        FROM org_group_students AS S
        INNER JOIN org_group_tree ogt ON S.org_group_id = ogt.descendant_group_id
        AND ogt.deleted_at IS NULL
        INNER JOIN org_group_faculty F ON F.org_group_id = ogt.ancestor_group_id
        AND ogt.deleted_at IS NULL and F.deleted_at is null
        WHERE S.deleted_at is null  AND F.person_id= :loggedInUserId 
        UNION ALL 
        SELECT S.person_id AS student_id,
        F.org_permissionset_id AS permissionset_id
        FROM org_course_student AS S
        INNER JOIN org_courses AS C ON C.id = S.org_courses_id AND C.deleted_at is null
        INNER JOIN org_course_faculty AS F ON F.org_courses_id = S.org_courses_id AND F.deleted_at is null
        INNER JOIN org_academic_terms AS OAT ON OAT.id = C.org_academic_terms_id  AND OAT.end_date >= now() AND OAT.deleted_at is null
        WHERE S.deleted_at is null  AND F.person_id= :loggedInUserId 
        ) AS merged
        INNER JOIN org_person_student AS P ON P.person_id=merged.student_id AND P.deleted_at IS NULL AND P.organization_id = :orgId
        INNER JOIN org_permissionset OPS ON merged.permissionset_id = OPS.id AND OPS.accesslevel_ind_agg = 1)
        AND AL.organization_id = :orgId
        AND AL.activity_type = 'A')
        AND (AL.deleted_at IS NULL)
        AND (CASE
        WHEN
        A.access_team = 1
        THEN
        APT.teams_id IN (SELECT
        teams_id
        FROM
        team_members
        WHERE
        person_id = :loggedInUserId) and :appointmentTeamAccess = 1
        ELSE CASE
        WHEN A.access_private = 1 THEN ARS.person_id_faculty = :loggedInUserId
        ELSE ((A.access_public = 1  and :appointmentPublicAccess = 1)
        OR ARS.person_id_faculty = :loggedInUserId)
        END
        END
        )
        $aAddYear $afacultyAccess
        GROUP BY AL.appointments_id ";

        $tempsql['email'] = " SELECT
        E.id AS activity_id,
        PS.external_id as external_id,
        PS.username as email,
        PS.id as student_id,
        acl.description as reason,
        '' as contact_type,
       	PS.firstname as student_firstname,
       	PS.lastname as student_lastname,
       	P.firstname AS faculty_firstname,
       	P.lastname AS faculty_lastname,
       	'' as assignedpersonname,
       	E.email_subject AS details,
       	'Email' as activity_type,
       	'' as activity_status,
        E.created_at AS created_at,
        E.access_private,
        E.access_public,
        E.access_team ,
        '' as has_attended,
        '' as interested_parties
        FROM activity_log AS AL
        LEFT JOIN email AS E ON AL.email_id = E.id
        LEFT JOIN person AS P ON E.person_id_faculty = P.id
        LEFT JOIN     person AS PS on PS.id = E.person_id_student
        LEFT JOIN email_teams AS ET ON E.id = ET.email_id
        LEFT JOIN related_activities as RA ON E.id = RA.email_id
        LEFT JOIN activity_log AL1 ON RA.activity_log_id = AL1.id
        left join activity_category as ac on (ac.id = E.activity_category_id)
        left join activity_category_lang as acl on (acl.activity_category_id = ac.id)
        LEFT JOIN email AS E1 ON AL1.appointments_id = E1.id
        WHERE E.organization_id = :orgId AND E.person_id_student in (SELECT DISTINCT merged.student_id
        FROM
        (
        SELECT S.person_id AS student_id,
        F.org_permissionset_id AS permissionset_id
        FROM org_group_students AS S
        INNER JOIN org_group_tree ogt ON S.org_group_id = ogt.descendant_group_id
        AND ogt.deleted_at IS NULL
        INNER JOIN org_group_faculty F ON F.org_group_id = ogt.ancestor_group_id
        AND ogt.deleted_at IS NULL and F.deleted_at is null
        WHERE S.deleted_at is null  AND F.person_id= :loggedInUserId 
        UNION ALL 
        SELECT S.person_id AS student_id,
        F.org_permissionset_id AS permissionset_id
        FROM org_course_student AS S
        INNER JOIN org_courses AS C ON C.id = S.org_courses_id AND C.deleted_at is null
        INNER JOIN org_course_faculty AS F ON F.org_courses_id = S.org_courses_id AND F.deleted_at is null
        INNER JOIN org_academic_terms AS OAT ON OAT.id = C.org_academic_terms_id  AND OAT.end_date >= now() AND OAT.deleted_at is null
        WHERE S.deleted_at is null  AND F.person_id= :loggedInUserId 
        ) AS merged
        INNER JOIN org_person_student AS P ON P.person_id=merged.student_id AND P.deleted_at IS NULL AND P.organization_id = :orgId
        INNER JOIN org_permissionset OPS ON merged.permissionset_id = OPS.id AND OPS.accesslevel_ind_agg = 1)
        AND E.deleted_at IS NULL AND (
        CASE WHEN AL1.activity_type IS NOT NULL AND ( AL1.activity_type = 'E' AND E1.access_private = 1) THEN E.person_id_faculty = :loggedInUserId ELSE
        CASE WHEN E.access_team = 1 THEN ET.teams_id IN (SELECT teams_id FROM team_members WHERE person_id = :loggedInUserId AND teams_id IN (SELECT teams_id from email_teams WHERE email_id = E.id AND deleted_at IS NULL))   AND :emailTeamAccess = 1 ELSE
        CASE WHEN E.access_private = 1 THEN E.person_id_faculty = :loggedInUserId ELSE ((E.access_public = 1 AND :emailPublicAccess = 1) OR E.person_id_faculty = :loggedInUserId)  END END END ) $eAddYear  $efacultyAccess GROUP BY E.id ";

        if ($type != NULL) {
            $sql = $tempsql[$type];
        } else {
            $sql = implode('union all', $tempsql);
        }

        $sql = $sql . ' order by created_at DESC';

        //reason routed permission fix

        $sql = str_replace("[referralTeamAccess]", $referralTeamAccess, $sql);
        $sql = str_replace("[referralPublicAccess]", $referralPublicAccess, $sql);
        $sql = str_replace("[referralPublicAccessReasonRouted]", $referralPublicAccessReasonRouted, $sql);
        $sql = str_replace("[referralTeamAccessReasonRouted]", $referralTeamAccessReasonRouted, $sql);

        //reason routed permission fix

        $parameters =
            [
                'orgId' => $orgId,
                'loggedInUserId' => $loggedInUserId,
                'rAddYear' => $rAddYear,
                'rfacultyAccess' => $rfacultyAccess,
                'contactPublicAccess' => $contactPublicAccess,
                'noteTeamAccess' => $noteTeamAccess,
                'contactTeamAccess' => $contactTeamAccess,
                'cAddYear' => $cAddYear,
                'cfacultyAccess' => $cfacultyAccess,
                'emailTeamAccess' => $emailTeamAccess,
                'appointmentTeamAccess' => $appointmentTeamAccess,
                'emailPublicAccess' => $emailPublicAccess,
                'notePublicAccess' => $notePublicAccess,
                'nAddYear' => $nAddYear,
                'nfacultyAccess' => $nfacultyAccess,
                'appointmentPublicAccess' => $appointmentPublicAccess,
                'aAddYear' => $aAddYear,
                'afacultyAccess' => $afacultyAccess,
                'eAddYear' => $eAddYear,
                'efacultyAccess' => $efacultyAccess,
                'yearStartDate' => $yearStartDate,
                'yearEndDate' => $yearEndDate,
                'accessPersonId' => $accessPersonId,
                'participantStudents' => $participantStudents
            ];

        $parametersTypes = ['participantStudents' => Connection::PARAM_INT_ARRAY];

        // adding in  participant check

        $mainSQL = "SELECT
                                                activity_id,
                                                external_id,
                                                email,
                                                student_id,
                                                reason,
                                                contact_type,
                                                student_firstname,
                                                student_lastname,
                                                faculty_firstname,
                                                faculty_lastname,
                                                assignedpersonname,
                                                details,
                                                activity_type,
                                                activity_status,
                                                created_at,
                                                access_private,
                                                access_public,
                                                access_team ,
                                                has_attended,
                                                interested_parties
                                          FROM ( $sql ) as derived 
                                          WHERE 
                                                derived.student_id IN ( :participantStudents );
        ";

        try {
            $stmt = $em->getConnection()->executeQuery($mainSQL, $parameters, $parametersTypes);

        } catch (\Exception $e) {
            throw new SynapseDatabaseException($e->getMessage() . ": " . $e->getTraceAsString());
        }

        return $stmt->fetchAll();
    }


    private function getLimit($pageNo,$offset){
        $startPoint = ($pageNo * $offset) - $offset;
        return " LIMIT $startPoint , $offset ";
    }

    /**
     *
     * Returns Top 5 issues from Issues_Calculation View
     *
     * @param int $loggedInPersonId
     * @param int $orgAcademicYearId
     * @param int $surveyId
     * @param int $orgId
     * @param int $cohortId
     * @param array $studentFilter
     * @return array
     */
    public function getTop5IssuesofPerson($loggedInPersonId, $orgAcademicYearId, $surveyId, $orgId, $cohortId, $studentFilter){

        $em = $this->getEntityManager();

        if(count($studentFilter) == 0) {
            return array();
        }


        $sql = "
            SELECT
                issue_id,
                `name`,
                SUM(has_issue) AS numerator,
                COUNT(*) AS denominator,
                (SUM(has_issue)/COUNT(*)) as percent,
                icon
            FROM
            (
                SELECT
                    org_id,
                    faculty_id,
                    student_id,
                    survey_id,
                    issue_id,
                    cohort,
                    `name`,
                    MAX(has_issue) AS has_issue,
                    icon
                FROM
                    Issues_Calculation
                WHERE
                  org_id = :orgId
                  AND org_academic_year_id = :orgAcademicYearId
                  AND faculty_id = :facultyId
                  AND survey_id = :surveyId
                  AND cohort = :cohort
                  AND student_id IN (:studentIds)
                 GROUP BY org_id, faculty_id, student_id, survey_id, issue_id, cohort
            ) AS derived
            GROUP BY org_id, faculty_id, survey_id, issue_id, cohort
            HAVING denominator > 9
            ORDER BY percent DESC, denominator DESC, issue_id DESC
            LIMIT 5;";

        $parameters =
            [
                'orgId'=>$orgId,
                'orgAcademicYearId'=>$orgAcademicYearId,
                'facultyId'=>$loggedInPersonId,
                'surveyId'=>$surveyId,
                'cohort'=>$cohortId,
                'studentIds'=>$studentFilter
            ];

        $parameterTypes =
            [
                'studentIds'=>Connection::PARAM_INT_ARRAY
            ];

        try{
            $stmt = $em->getConnection()->executeQuery($sql, $parameters, $parameterTypes);
        } catch (\Exception $e) {
            throw new SynapseDatabaseException($e->getMessage() . ": " . $e->getTraceAsString());;
        }
        return $stmt->fetchAll();


    }

    /**
     * Get all non coordinator reports
     *
     * @return array|null
     */
    public function getAllNonCoordinatorsReports()
    {
        $sql = "SELECT 
                    rv.view_name,
                    rp.id,                    
                    rp.name,
                    rp.description,
                    rp.is_batch_job,
                    rp.is_coordinator_report,
                    rp.short_code,
                    rp.is_active
                FROM
                    reports rp
                        INNER JOIN
                    report_view rv ON rp.report_view_id = rv.id
                WHERE
                    rp.is_active = 'y'
                    AND (rp.is_coordinator_report != 'y' OR rp.is_coordinator_report IS NULL)
                    AND rp.deleted_at IS NULL
                    AND rv.deleted_at IS NULL
                ORDER BY rp.name ASC";
        $result = $this->executeQueryFetchAll($sql);
        return $result;
    }

    /**
     * Get all coordinator reports
     *
     * @param array $reportIds
     * @return array|null
     */
    public function getAllCoordinatorReports()
    {
        $sql = "SELECT 
                    rv.view_name,
                    rp.id,
                    rp.name,
                    rp.description,
                    rp.is_batch_job,
                    rp.is_coordinator_report,
                    rp.short_code,
                    rp.is_active
                FROM
                    reports rp
                        INNER JOIN
                    report_view rv ON rp.report_view_id = rv.id
                WHERE
                    rp.is_active = 'y'
                    AND rp.is_coordinator_report = 'y'
                    AND rp.deleted_at IS NULL
                    AND rv.deleted_at IS NULL 
                ORDER BY `name` ASC";
        $result = $this->executeQueryFetchAll($sql);
        return $result;
    }

    /**
     * Get reports type TeamLeader
     *
     * @param array $reportIds
     * @return array|null
     */
    public function getReportsTeamLeader($reportIds = [])
    {
        if (empty($reportIds)) {
            $reportIds = [-1];
        }
        $parameters = [
            "reportIds" => $reportIds
        ];
        $parameterTypes = [
            "reportIds" => Connection::PARAM_INT_ARRAY
        ];
        $sql = "SELECT
                    rv.view_name,
                    rp.id,
                    rp.name,
                    rp.description,
                    rp.is_batch_job,
                    rp.is_coordinator_report,
                    rp.short_code,
                    rp.is_active
                FROM
                    reports rp
                        INNER JOIN
                    report_view rv ON rp.report_view_id = rv.id
                WHERE
                    rp.is_active = 'y'
                    AND (rp.id IN (:reportIds) OR rp.short_code = 'FUR')                  
                    AND rp.deleted_at IS NULL
                    AND rv.deleted_at IS NULL                
                ORDER BY `name` ASC";

        $result = $this->executeQueryFetchAll($sql, $parameters, $parameterTypes);
        return $result;
    }

    /**
     * Get specific reports
     *
     * @param array $reportIds
     * @return array|null
     */
    public function getSpecificReports($reportIds)
    {
        $parameters = [
            "reportIds" => $reportIds
        ];
        $parameterTypes = [
            "reportIds" => Connection::PARAM_INT_ARRAY
        ];
        $sql = "SELECT
                    rv.view_name,
                    rp.id,                   
                    rp.name,
                    rp.description,
                    rp.is_batch_job,
                    rp.is_coordinator_report,
                    rp.short_code,
                    rp.is_active
                FROM
                    reports rp
                        INNER JOIN
                    report_view rv ON rp.report_view_id = rv.id
                WHERE
                    rp.is_active = 'y' 
                    AND rp.id IN (:reportIds)
                    AND rp.deleted_at IS NULL
                    AND rv.deleted_at IS NULL
                ORDER BY rp.name ASC";

        $result = $this->executeQueryFetchAll($sql, $parameters, $parameterTypes);
        return $result;
    }

    /**
     * Returns faculty usage details for the filtered faculty list.
     *
     * @param int $orgId
     * @param array $filteredFacultyList
     * @param string $startDate
     * @param string $endDate
     * @param array $academicYearIds
     * @return array
     * @throws SynapseDatabaseException
     */
    public function getFacultyUsage($orgId, $filteredFacultyList, $startDate, $endDate, $academicYearIds)
    {
        $parameters = [
            'orgId' => $orgId,
            'startDate' => $startDate,
            'endDate' => $endDate,
            'filteredFacultyList' => $filteredFacultyList,
            'academicYearIds' => $academicYearIds
        ];

        $parameterTypes = ['filteredFacultyList' => Connection::PARAM_INT_ARRAY, 'academicYearIds' => Connection::PARAM_INT_ARRAY];
        $sql = "SELECT
                    per.person_id,
                    p.lastname,
                    p.firstname,
                    p.external_id,
                    p.username,
                    student_connected,
                    contacts_student_count,
                    ROUND((contacts_student_count / student_connected) * 100, 2) AS contacted_student_percentage,
                    interaction_contact_student_count,
                    ROUND((interaction_contact_student_count / student_connected) * 100, 2) AS interaction_contact_student_percentage,
                    reports_viewed_student_count,
                    ROUND((reports_viewed_student_count / student_connected) * 100, 2) AS reports_viewed_student_percentage,
                    notes_count,
                    referrals_count,
                    last_login,
                    days_login
                FROM
                    org_person_faculty per
                        INNER JOIN
                    person p ON p.id = per.person_id
                        AND p.deleted_at IS NULL
                        LEFT JOIN
                    (
                        SELECT
                            merged.faculty_id AS faculty_id,
                            COUNT(DISTINCT merged.student_id) AS student_connected
                        FROM
                            (
                                SELECT
                                    ogfspm.student_id,
                                    ogfspm.faculty_id
                                FROM
                                    org_group_faculty_student_permission_map ogfspm
                                WHERE
                                    ogfspm.org_id = :orgId

                                UNION ALL

                                SELECT
                                    S.person_id AS student_id,
                                    F.person_id AS faculty_id
                                FROM
                                    org_course_student AS S
                                        INNER JOIN
                                    org_courses AS C ON C.id = S.org_courses_id
                                            AND C.deleted_at IS NULL
                                        INNER JOIN
                                    org_academic_terms AS OAT ON C.org_academic_terms_id = OAT.id
                                            AND OAT.deleted_at IS NULL
                                        INNER JOIN
                                    org_course_faculty AS F ON F.org_courses_id = S.org_courses_id
                                            AND F.deleted_at IS NULL
                                            AND F.organization_id = S.organization_id
                                WHERE
                                    S.deleted_at IS NULL
                                        AND ((DATE(OAT.start_date) BETWEEN :startDate AND :endDate) OR (DATE(OAT.end_date) BETWEEN :startDate AND :endDate) OR ((:startDate BETWEEN OAT.start_date AND OAT.end_date) OR (:endDate BETWEEN OAT.start_date AND OAT.end_date)))
                                        AND S.organization_id = :orgId
                            ) AS merged
                            INNER JOIN org_person_student_year AS opsy ON opsy.person_id = merged.student_id
                        WHERE
                            merged.faculty_id IN (:filteredFacultyList)
                                AND opsy.deleted_at IS NULL
                                AND opsy.org_academic_year_id IN (:academicYearIds)
                        GROUP BY merged.faculty_id
                    ) AS students_count_view ON students_count_view.faculty_id = per.person_id
                        LEFT JOIN
                    (
                        SELECT
                            c.person_id_faculty AS faculty_id,
                                COUNT(DISTINCT (c.person_id_student)) AS interaction_contact_student_count
                        FROM
                            contacts c
                        INNER JOIN contact_types ct ON ct.id = c.contact_types_id
                            AND ct.parent_contact_types_id = 1
                        INNER JOIN org_person_student_year AS opsy ON opsy.person_id = c.person_id_student
                        WHERE
                            c.deleted_at IS NULL
                                AND c.organization_id = :orgId
                                AND DATE(c.contact_date) BETWEEN :startDate AND :endDate
                                AND c.person_id_faculty IN (:filteredFacultyList)
                                AND opsy.deleted_at IS NULL
	                            AND opsy.org_academic_year_id IN (:academicYearIds)
                        GROUP BY c.person_id_faculty
                    ) AS interaction_contacts_view ON interaction_contacts_view.faculty_id = per.person_id
                        LEFT JOIN
                    (
                        SELECT
                            c.person_id_faculty AS faculty_id,
                                COUNT(DISTINCT (c.person_id_student)) AS contacts_student_count
                        FROM
                            contacts c
                        INNER JOIN org_person_student_year AS opsy ON opsy.person_id = c.person_id_student
                        WHERE
                            c.deleted_at IS NULL
                                AND c.organization_id = :orgId
                                AND DATE(c.contact_date) BETWEEN :startDate AND :endDate
                                AND c.person_id_faculty IN (:filteredFacultyList)
                                AND opsy.deleted_at IS NULL
	                            AND opsy.org_academic_year_id IN (:academicYearIds)
                        GROUP BY c.person_id_faculty
                    ) AS contacts_view ON contacts_view.faculty_id = per.person_id
                        LEFT JOIN
                    (
                        SELECT
                            oah.person_id AS faculty_id,
                                COUNT(DISTINCT oah.student_id) AS reports_viewed_student_count
                        FROM
                            org_survey_report_access_history oah
                        INNER JOIN org_person_student_year AS opsy ON opsy.person_id = oah.student_id
                        WHERE
                            oah.org_id = :orgId
                                AND oah.person_id IN (:filteredFacultyList)
                                AND DATE(oah.last_accessed_on) BETWEEN :startDate AND :endDate
                                AND opsy.deleted_at IS NULL
	                            AND opsy.org_academic_year_id IN (:academicYearIds)
                        GROUP BY oah.person_id
                    ) AS reports_view ON reports_view.faculty_id = per.person_id
                        LEFT JOIN
                    (
                        SELECT
                            person_id_faculty AS faculty_id, COUNT(n.id) AS notes_count
                        FROM
                            note n
                        INNER JOIN org_person_student_year AS opsy ON opsy.person_id = n.person_id_student
                        WHERE
                            n.organization_id = :orgId
                                AND n.deleted_at IS NULL
                                AND person_id_faculty IN (:filteredFacultyList)
                                AND DATE(n.created_at) BETWEEN :startDate AND :endDate
                                AND opsy.deleted_at IS NULL
	                            AND opsy.org_academic_year_id IN (:academicYearIds)
                        GROUP BY person_id_faculty
                    ) AS notes_view ON notes_view.faculty_id = per.person_id
                        LEFT JOIN
                    (
                        SELECT
                            person_id_faculty AS faculty_id,
                                COUNT(r.id) AS referrals_count
                        FROM
                            referrals r
                        INNER JOIN org_person_student_year AS opsy ON opsy.person_id = r.person_id_student
                        WHERE
                            r.organization_id = :orgId
                                AND r.deleted_at IS NULL
                                AND r.person_id_faculty IN (:filteredFacultyList)
                                AND DATE(r.created_at) BETWEEN :startDate AND :endDate
                                AND opsy.deleted_at IS NULL
	                            AND opsy.org_academic_year_id IN (:academicYearIds)
                        GROUP BY person_id_faculty
                    ) AS referrals_view ON referrals_view.faculty_id = per.person_id
                        LEFT JOIN
                    (
                        SELECT
                            person_id, created_at AS last_login
                        FROM
                            access_log al
                        WHERE
                            al.organization_id = :orgId
                                AND al.event = 'Login'
                                AND al.created_at = (SELECT
                                    alog.created_at
                                FROM
                                    access_log alog
                                WHERE
                                    alog.person_id = al.person_id
                                        AND alog.organization_id = :orgId
                                        AND alog.event = 'Login'
                                        AND DATE(alog.created_at) BETWEEN :startDate AND :endDate
                                        AND person_id IN (:filteredFacultyList)
                                ORDER BY alog.created_at DESC
                                LIMIT 1)
                    ) AS last_login ON last_login.person_id = per.person_id
                        LEFT JOIN
                    (
                        SELECT
                            person_id, COUNT(DISTINCT DATE(created_at)) AS days_login
                        FROM
                            access_log al
                        WHERE
                            al.organization_id = :orgId
                                AND al.event = 'Login'
                                AND DATE(al.created_at) BETWEEN :startDate AND :endDate
                                AND person_id IN (:filteredFacultyList)
                        GROUP BY person_id
                    ) AS days_login ON days_login.person_id = per.person_id
                WHERE
                    per.organization_id = :orgId
                        AND per.deleted_at IS NULL
                        AND per.person_id IN (:filteredFacultyList)
                ORDER BY per.person_id;";


        try {
            $entityManager = $this->getEntityManager();
            $stmt = $entityManager->getConnection()->executeQuery($sql, $parameters, $parameterTypes);
        } catch (\Exception $e) {
            throw new SynapseDatabaseException($e->getMessage() . ": " . $e->getTraceAsString());
        }
        $results = $stmt->fetchAll();
        return $results;

    }

    /**
     * Gets an array of distinct IDs where a faculty member is in at least one of the provided
     * groupIds AND at least one of the provided teamIds
     *
     * @param int $organizationId
     * @param array $groupIds
     * @param array $teamIds
     * @throws SynapseDatabaseException
     * @return array:
     */
    public function getFacultyIdsInAnIntersectionBetweenTeamsAndGroups($organizationId, $groupIds, $teamIds)
    {
        $sql = "SELECT DISTINCT
                    ogf.person_id AS faculty_id
                FROM
                    org_group_faculty ogf
                        INNER JOIN
                    team_members tm ON tm.person_id = ogf.person_id
                        AND tm.organization_id = ogf.organization_id
                WHERE
                    ogf.organization_id = :organizationId
                        AND ogf.deleted_at IS NULL
                        AND tm.deleted_at IS NULL
                        AND ogf.org_group_id IN (:groupIds)
                        AND tm.teams_id IN (:teamIds)";
        try {
            $stmt = $this->getEntityManager()
                ->getConnection()
                ->executeQuery($sql, array(
                    'organizationId' => $organizationId,
                    'groupIds' => $groupIds,
                    'teamIds' => $teamIds
                ), array(
                    'groupIds' => \Doctrine\DBAL\Connection::PARAM_INT_ARRAY,
                    'teamIds' => \Doctrine\DBAL\Connection::PARAM_INT_ARRAY,
                ));

            $result = $stmt->fetchAll();
        } catch (\Exception $e) {
            throw new SynapseDatabaseException($e->getMessage() . ": " . $e->getTraceAsString());
        }
        return $result;
    }

    public function getRetentionTrackStudents($orgId, $academicYearId)
    {
        $metaKey = 'RetentionTrack';
        $em = $this->getEntityManager();
        $qb = $em->createQueryBuilder()
            ->select('p.id')
            ->from('SynapseCoreBundle:PersonEbiMetadata', 'pem')
            ->join('SynapseCoreBundle:Person', 'p', \Doctrine\ORM\Query\Expr\Join::WITH, 'pem.person = p.id')
            ->join('SynapseCoreBundle:EbiMetadata', 'em', \Doctrine\ORM\Query\Expr\Join::WITH, 'pem.ebiMetadata = em.id')
            ->where('em.key = :metakey')
            ->andWhere('pem.metadataValue = :metaValue')
            ->andWhere('pem.orgAcademicYear = :academicYearId')
            ->andWhere('p.organization = :orgId')
            ->setParameters(array(
                'metakey' => $metaKey,
                'academicYearId' => $academicYearId,
                'orgId' => $orgId,
                'metaValue' => 1
            ))
            ->getQuery();
        $resultSet = $qb->getResult();
        $finalArr = array();
        foreach ($resultSet as $res) {
            $finalArr[] = $res['id'];
        }
        return $finalArr;
    }

    /**
     * Get Aggregated Retention Data with Risk for passed in student id and retention tracking data
     *
     * @param Date $riskStartDate
     * @param Date $riskEndDate
     * @param int $organizationId
     * @param string $currentYearId
     * @param string $retentionTrackingYear
     * @param array $filteredStudents
     * @throws SynapseDatabaseException
     * @return array
     */
    public function getAggregatedRetentionVariablesWithRisk($riskStartDate, $riskEndDate, $organizationId, $currentYearId, $retentionTrackingYear, $filteredStudents)
    {
        $parameters = [
            'riskStartDate' => $riskStartDate,
            'riskEndDate' => $riskEndDate,
            'organizationId' => $organizationId,
            'currentYearId' => $currentYearId,
            'retentionTrackingYear' => $retentionTrackingYear,
            'filteredStudents' => $filteredStudents
        ];

        $parameterTypes = ['filteredStudents' => Connection::PARAM_INT_ARRAY];

        $sql = "SELECT
                    merged.years_from_retention_track,
                    CASE
                        WHEN merged.risk_level THEN rl.risk_text
                        ELSE 'gray'
                    END AS risk_level_text,
                    merged.risk_level,
                    SUM(merged.is_enrolled_midyear) AS midyear_numerator_count,
                    SUM(CASE
                            WHEN
                                merged.years_from_retention_track = 0
                                    AND is_enrolled_beginning_year = 1
                            THEN
                                0
                            ELSE merged.is_enrolled_beginning_year
                        END) AS beginning_year_numerator_count,
                    COUNT(DISTINCT merged.person_id) AS denominator_count
                FROM
                    risk_level rl
                        LEFT JOIN
                    (SELECT
                        opsrbtgv.person_id,
                        NULL AS risk_level,
                        '' AS date_captured,
                        opsrbtgv.is_enrolled_beginning_year,
                        opsrbtgv.is_enrolled_midyear,
                        opsrbtgv.years_from_retention_track
                    FROM
                        org_person_student_retention_by_tracking_group_view opsrbtgv
                            LEFT JOIN
                        person_risk_level_history prlh ON opsrbtgv.person_id = prlh.person_id
                            AND DATE(prlh.date_captured) BETWEEN :riskStartDate AND :riskEndDate
                    WHERE
                        opsrbtgv.organization_id = :organizationId
                            AND opsrbtgv.year_id <= :currentYearId
                            AND prlh.person_id IS NULL
                            AND opsrbtgv.retention_tracking_year = :retentionTrackingYear
                            AND opsrbtgv.person_id IN ( :filteredStudents )
                    UNION ALL
                    SELECT
                        prlh.person_id,
                        prlh.risk_level,
                        prlh.date_captured,
                        opsrbtgv.is_enrolled_beginning_year,
                        opsrbtgv.is_enrolled_midyear,
                        opsrbtgv.years_from_retention_track
                    FROM
                        (SELECT
                            person_id,
                            MAX(date_captured) AS date_captured
                        FROM
                            person_risk_level_history
                        WHERE
                            DATE(date_captured) BETWEEN :riskStartDate AND :riskEndDate
                                AND person_id IN( :filteredStudents )
                        GROUP BY person_id) AS person_risk_date
                            INNER JOIN
                        person_risk_level_history prlh ON prlh.person_id = person_risk_date.person_id
                            AND prlh.date_captured = person_risk_date.date_captured
                            INNER JOIN
                        org_person_student_retention_by_tracking_group_view opsrbtgv ON prlh.person_id = opsrbtgv.person_id
                    WHERE
                        opsrbtgv.organization_id = :organizationId
                            AND opsrbtgv.year_id <= :currentYearId
                            AND opsrbtgv.retention_tracking_year = :retentionTrackingYear
                            AND opsrbtgv.person_id IN ( :filteredStudents )) AS merged ON merged.risk_level = rl.id
                        OR (merged.risk_level IS NULL
                        AND rl.risk_text = 'gray')
                GROUP BY merged.years_from_retention_track , merged.risk_level
                HAVING denominator_count > 0
                ORDER BY merged.years_from_retention_track , merged.risk_level DESC";
        try {
            $em = $this->getEntityManager();
            $stmt = $em->getConnection()->executeQuery($sql, $parameters, $parameterTypes);
            $results = $stmt->fetchAll();
        } catch (\Exception $e) {
            throw new SynapseDatabaseException($e->getMessage() . ": " . $e->getTraceAsString());
        }
        return $results;
    }

    public function getOverAllCount($orgYearId, $retentionType , $students)
    {
        $sql = "select count(distinct (person_id)) as cnt from person_ebi_metadata as pem
                join ebi_metadata as em
                on pem.ebi_metadata_id = em.id
                WHERE
                em.meta_key = :retentionType
                and org_academic_year_id = :orgYearId
                and metadata_value in (0, 1)
                and pem.deleted_at IS NULL
                and  person_id IN ( :students )
                ";

        $stmt = $this->getEntityManager()
            ->getConnection()
            ->executeQuery($sql, array(
                'orgYearId' => $orgYearId,
                'retentionType' => $retentionType,
                'students' => $students
            ), array(
                'students' => \Doctrine\DBAL\Connection::PARAM_INT_ARRAY
            ));
        $result = $stmt->fetchAll();
        return $result[0]['cnt'];
    }

    public function getColorCodeNumber($filteredStudents, $riskStartDate, $riskEndDate){
        //Needs to be refactored
        $sql = "SELECT risk_level_text ,  count(risk_level_text) as cnt  FROM (select
            (case
        when merged.risk_level = 1 then 'red2'
        when merged.risk_level = 2 then 'red'
        when merged.risk_level = 3 then 'yellow'
        when merged.risk_level = 4 then 'green'
        else 'gray'
    end) as risk_level_text
from
#-- students who are not having risk calculation value
        (select
            p.id as person_id,
                '' as risk_level,
                '' as date_captured
        from
            person p
        where
            p.deleted_at is null
            and p.id NOT IN (select
                person_id
            from
                person_risk_level_history
            where
                date(date_captured) between :riskStartDate and :riskEndDate)
            and p.id in ( :filteredStudents )
    union all
#-- students who are having risk value within a specified date range and get last value
        select
            a.person_id,
            a.risk_level,
            a.date_captured
        from
            (select
            person_id, risk_level, max(date_captured) as date_captured
        from
            person_risk_level_history
        where
            date(date_captured) between :riskStartDate and :riskEndDate
        group by person_id) as b
        inner join person_risk_level_history as a ON a.person_id = b.person_id
            and a.date_captured = b.date_captured
     
          
        where
            a.person_id in ( :filteredStudents )
            and date(a.date_captured) between  :riskStartDate and :riskEndDate) as merged
            group by merged.risk_level , merged.person_id ) as merged1 group by risk_level_text";



        $stmt = $this->getEntityManager()
            ->getConnection()
            ->executeQuery($sql, array(
                'riskStartDate' => $riskStartDate,
                'riskEndDate' => $riskEndDate,
                'filteredStudents' => $filteredStudents
            ), array(
                'filteredStudents' => \Doctrine\DBAL\Connection::PARAM_INT_ARRAY
            ));


        $result = $stmt->fetchAll();

        return $result;
    }

    /**
     * Get Aggregated Completion data with risk based on student IDs and retention tracking year passed in
     *
     * @param string $riskStartDate
     * @param string $riskEndDate
     * @param int $organizationId
     * @param string $currentYearId
     * @param string $retentionTrackingYear
     * @param array $studentIds
     * @throws SynapseDatabaseException
     * @return array
     */
    public function getAggregatedCompletionVariablesWithRisk($riskStartDate, $riskEndDate, $organizationId, $currentYearId, $retentionTrackingYear, $studentIds)
    {
        $parameters = [
            'riskStartDate' => $riskStartDate,
            'riskEndDate' => $riskEndDate,
            'organizationId' => $organizationId,
            'currentYearId' => $currentYearId,
            'retentionTrackingYear' => $retentionTrackingYear,
            'filteredStudents' => $studentIds
        ];

        $parameterTypes = ['filteredStudents' => Connection::PARAM_INT_ARRAY];

        $sql = "SELECT
                    merged.years_from_retention_track,
                    CASE
                        WHEN merged.risk_level THEN rl.risk_text
                        ELSE 'gray'
                    END AS risk_level_text,
                    merged.risk_level,
                    SUM(merged.is_degree_completed) AS numerator_count,
                    COUNT(DISTINCT merged.person_id) AS denominator_count
                FROM
                    risk_level rl
                        LEFT JOIN
                    (SELECT
                        opsrwdcv.person_id,
                        NULL AS risk_level,
                        '' AS date_captured,
                        opsrwdcv.is_degree_completed,
                        opsrwdcv.years_from_retention_track
                    FROM
                        (SELECT 
                            opsrbtgv.organization_id,
                            opsrbtgv.person_id,
                            opsrbtgv.retention_tracking_year,
                            opsrbtgv.year_id,
                            opsrbtgv.year_name,
                            opsrbtgv.is_enrolled_beginning_year,
                            opsrbtgv.is_enrolled_midyear,
                            (CASE
                                WHEN (opsrbtgv.is_degree_completed = 1) THEN 1
                                WHEN
                                    ((SELECT 
                                            opsr1.year_id
                                        FROM
                                            org_person_student_retention_view opsr1
                                        WHERE
                                            ((opsr1.person_id = opsrbtgv.person_id)
                                                AND (opsr1.organization_id = opsrbtgv.organization_id)
                                                AND (opsr1.is_degree_completed = 1)
                                                AND (opsr1.year_id >= opsrbtgv.retention_tracking_year))
                                        ORDER BY opsr1.year_id
                                        LIMIT 1) <= opsrbtgv.year_id)
                                THEN
                                    1
                                ELSE 0
                            END) AS is_degree_completed,
                            opsrbtgv.years_from_retention_track AS years_from_retention_track
                        FROM
                            org_person_student_retention_by_tracking_group_view opsrbtgv
                        WHERE
                            retention_tracking_year = :retentionTrackingYear
                                AND organization_id = :organizationId) AS opsrwdcv
                            LEFT JOIN
                        person_risk_level_history prlh ON opsrwdcv.person_id = prlh.person_id
                            AND DATE(prlh.date_captured) BETWEEN :riskStartDate AND :riskEndDate
                    WHERE
                        opsrwdcv.organization_id = :organizationId
                            AND opsrwdcv.year_id <= :currentYearId
                            AND prlh.person_id IS NULL
                            AND opsrwdcv.retention_tracking_year = :retentionTrackingYear
                            AND opsrwdcv.person_id IN (:filteredStudents)
                    UNION ALL
                    SELECT
                        prlh.person_id,
                        prlh.risk_level,
                        prlh.date_captured,
                        opsrwdcv.is_degree_completed,
                        opsrwdcv.years_from_retention_track
                    FROM
                        (SELECT
                            person_id,
                            MAX(date_captured) AS date_captured
                        FROM
                            person_risk_level_history
                        WHERE
                            DATE(date_captured) BETWEEN :riskStartDate AND :riskEndDate
                                AND person_id IN (:filteredStudents)
                        GROUP BY person_id) AS person_risk_date
                            INNER JOIN
                        person_risk_level_history prlh ON prlh.person_id = person_risk_date.person_id
                            AND prlh.date_captured = person_risk_date.date_captured
                            INNER JOIN
                        (SELECT
                            opsrbtgv.organization_id,
                            opsrbtgv.person_id,
                            opsrbtgv.retention_tracking_year,
                            opsrbtgv.year_id,
                            opsrbtgv.year_name ,
                            opsrbtgv.is_enrolled_beginning_year,
                            opsrbtgv.is_enrolled_midyear,
                            (CASE
                                WHEN (opsrbtgv.is_degree_completed = 1) THEN 1
                                WHEN
                                    ((SELECT
                                            opsr1.year_id
                                        FROM
                                            org_person_student_retention_view opsr1
                                        WHERE
                                            ((opsr1.person_id = opsrbtgv.person_id)
                                                AND (opsr1.organization_id = opsrbtgv.organization_id)
                                                AND (opsr1.is_degree_completed = 1)
                                                AND (opsr1.year_id >= opsrbtgv.retention_tracking_year))
                                        ORDER BY opsr1.year_id
                                        LIMIT 1) <= opsrbtgv.year_id)
                                THEN
                                    1
                                ELSE 0
                            END) AS is_degree_completed,
                            opsrbtgv.years_from_retention_track AS years_from_retention_track
                        FROM
                            org_person_student_retention_by_tracking_group_view opsrbtgv
                        WHERE
                            retention_tracking_year = :retentionTrackingYear
                                AND organization_id = :organizationId) AS opsrwdcv ON prlh.person_id = opsrwdcv.person_id
                    WHERE
                        opsrwdcv.organization_id = :organizationId
                            AND opsrwdcv.year_id <= :currentYearId
                            AND opsrwdcv.retention_tracking_year = :retentionTrackingYear
                            AND opsrwdcv.person_id IN (:filteredStudents)) AS merged ON merged.risk_level = rl.id
                        OR (merged.risk_level IS NULL
                        AND rl.risk_text = 'gray')
                GROUP BY merged.years_from_retention_track , merged.risk_level
                HAVING denominator_count > 0
                ORDER BY merged.years_from_retention_track , merged.risk_level DESC";

        $result = $this->executeQueryFetchAll($sql, $parameters, $parameterTypes);
        return $result;
    }


    /**
     * Get individual response report data
     *
     * @param int $surveyId
     * @param string $studentListFilterQuery
     * @param string $calculateLimit
     * @param bool $respondedFlag
     * @param bool $studentListFlag
     * @param string $sortByQueryString
     * @return array
     * @throws SynapseDatabaseException
     */
    public function getIndividualResponseReportData($surveyId, $studentListFilterQuery, $calculateLimit = '', $respondedFlag = false, $studentListFlag = false, $sortByQueryString = '')
    {
        $parameters = [
            'surveyId' => $surveyId
        ];

        $groupBy = " ";
        $deterministicSort = "p.lastname, p.firstname, p.id DESC";

        switch (trim($sortByQueryString)) {
            case 'last_name':
            case '+last_name':
                $orderBy = "ORDER BY p.lastname, p.firstname, p.id DESC";
                break;
            case '-last_name':
                $orderBy = "ORDER BY p.lastname DESC, p.firstname, p.id DESC";
                break;
            case 'email':
            case '+email':
                $orderBy = "ORDER BY email, " . $deterministicSort;
                break;
            case '-email':
                $orderBy = "ORDER BY email DESC, " . $deterministicSort;
                break;
            case 'phone_number':
            case '+phone_number':
                $orderBy = "ORDER BY phone_number, " . $deterministicSort;
                break;
            case '-phone_number':
                $orderBy = "ORDER BY phone_number DESC, " . $deterministicSort;
                break;
            case 'opted_out':
            case '+opted_out':
                $orderBy = "ORDER BY opted_out, " . $deterministicSort;
                break;
            case '-opted_out':
                $orderBy = "ORDER BY opted_out DESC, " . $deterministicSort;
                break;
            case 'responded_at':
            case '+responded_at':
                $orderBy = "ORDER BY responded_at, " . $deterministicSort;
                break;
            case '-responded_at':
                $orderBy = "ORDER BY responded_at DESC, " . $deterministicSort;
                break;
            case 'responded':
            case '+responded':
                $orderBy = "ORDER BY survey_responded_status, " . $deterministicSort;
                break;
            case '-responded':
                $orderBy = "ORDER BY survey_responded_status DESC, " . $deterministicSort;
                break;
            default:
                $orderBy = "ORDER BY " . $deterministicSort;
                break;
        }

        if ($respondedFlag) {
            $selectQuerySubstring = " COUNT(DISTINCT(p.id)) AS count ";
            $respondedCondition = " AND opssl.Has_Responses = 'Yes' ";
        } else {
            if ($studentListFlag) {
                $selectQuerySubstring = " p.id AS student_id,
                    p.firstname AS first_name,
                    p.lastname AS last_name ";
            } else {
                $selectQuerySubstring = " SQL_CALC_FOUND_ROWS p.id AS person_id,
                    p.external_id AS student_id,
                    p.firstname AS first_name,
                    p.lastname AS last_name,
                    ci.primary_email AS email,
                    ci.primary_mobile AS phone_number,
                    CASE WHEN
                            opssl.survey_opt_out_status = 'Yes'
                         THEN
                            'Yes'
                         ELSE
                            'No'
                    END AS opted_out,
                    opssl.survey_completion_status AS survey_status,
                    opssl.survey_completion_date AS responded_at,
                    CASE WHEN
                            opssl.Has_Responses = 'Yes'
                         THEN
                            'Yes'
                         ELSE
                            'No'
                    END AS survey_responded_status ";
            }
            $groupBy = "  GROUP BY p.id  ";
            $respondedCondition = " ";
        }

        $sql = "SELECT 
            $selectQuerySubstring
            FROM
                person p
                    INNER JOIN
                person_contact_info pci ON p.id = pci.person_id
                    INNER JOIN
                contact_info ci ON ci.id = pci.contact_id
                    INNER JOIN
                org_person_student_survey_link opssl ON opssl.person_id = p.id
                    INNER JOIN
                org_person_student_survey opss
                        ON opss.person_id = p.id
                        AND opss.organization_id = p.organization_id
                        AND opssl.survey_id = opss.survey_id
            WHERE
                (opss.receive_survey = 1 OR (opss.receive_survey = 0 AND opssl.Has_Responses = 'Yes'))
                AND opssl.deleted_at IS NULL
                AND pci.deleted_at IS NULL
                AND ci.deleted_at IS NULL
                AND opss.deleted_at IS NULL 
                AND opss.survey_id = :surveyId 
                $respondedCondition
                AND $studentListFilterQuery
                $groupBy
                $orderBy
                $calculateLimit ";

        try {
            $em = $this->getEntityManager();
            $statement = $em->getConnection()->executeQuery($sql, $parameters);
            $result = $statement->fetchAll();
        } catch (\Exception $e) {
            throw new SynapseDatabaseException($e->getMessage() . ": " . $e->getTraceAsString());
        }
        return $result;
    }

    /**
     * Get all academic update report information based on criteria
     * TODO: The person_with_risk_intent_denullifier CANNOT be used here currently because of $studentSelectSQL from Custom Search
     *
     * @param int $organizationId
     * @param int $currentAcademicYearId
     * @param string $studentSelectSQL
     * @param string $academicUpdateFilterCriteria
     * @param string $sortByQueryString
     * @param string $limit
     * @param bool $studentListFlag
     * @param bool $isCount
     * @param bool $participationFlag
     * @return array
     * @throws SynapseDatabaseException
     */
    public function getAllAcademicUpdateReportInformationBasedOnCriteria($organizationId, $currentAcademicYearId, $studentSelectSQL, $academicUpdateFilterCriteria, $sortByQueryString = '', $limit = '', $studentListFlag = false, $isCount = false, $participationFlag = true)
    {
        $parameters = [
            'organizationId' => $organizationId,
            'currentAcademicYearId' => $currentAcademicYearId
        ];

        if (!empty($sortByQueryString)) {
            $deterministicSort = 'p.lastname, p.firstname, p.id DESC, au.update_date ASC, oc.course_section_id ASC, au.id DESC';

            switch ($sortByQueryString) {
                case 'student_last_name':
                case '+student_last_name':
                    $orderBy = 'ORDER BY ' . $deterministicSort;
                    break;
                case '-student_last_name':
                    $orderBy = 'ORDER BY p.lastname DESC, p.firstname, p.id DESC, au.update_date ASC, oc.course_section_id ASC, au.id DESC';
                    break;
                case 'risk_text':
                case '+risk_text':
                    $orderBy = 'ORDER BY rl.id, ' . $deterministicSort;
                    break;
                case '-risk_text':
                    $orderBy = 'ORDER BY rl.id DESC, ' . $deterministicSort;
                    break;
                case 'course_name':
                case '+course_name':
                    $orderBy = 'ORDER BY CONCAT(oc.subject_code, oc.course_number), ' . $deterministicSort;
                    break;
                case '-course_name':
                    $orderBy = 'ORDER BY CONCAT(oc.subject_code, oc.course_number) DESC, ' . $deterministicSort;
                    break;
                case 'absences':
                case '+absences':
                    $orderBy = 'ORDER BY au.absence, ' . $deterministicSort;
                    break;
                case '-absences':
                    $orderBy = 'ORDER BY au.absence DESC, ' . $deterministicSort;
                    break;
                case 'created_at':
                case '+created_at':
                    $orderBy = 'ORDER BY au.update_date, p.lastname, p.firstname, p.id DESC, oc.course_section_id ASC, au.id DESC';
                    break;
                case '-created_at':
                    $orderBy = 'ORDER BY au.update_date DESC, p.lastname, p.firstname, p.id DESC, oc.course_section_id ASC, au.id DESC';
                    break;
                case 'failure_risk':
                case '+failure_risk':
                    $orderBy = 'ORDER BY au.failure_risk_level, ' . $deterministicSort;
                    break;
                case '-failure_risk':
                    $orderBy = 'ORDER BY au.failure_risk_level DESC, ' . $deterministicSort;
                    break;
                case 'inprogress_grade':
                case '+inprogress_grade':
                    $orderBy = 'ORDER BY au.grade, ' . $deterministicSort;
                    break;
                case '-inprogress_grade':
                    $orderBy = 'ORDER BY au.grade DESC, ' . $deterministicSort;
                    break;
                case 'comment':
                case '+comment':
                    $orderBy = 'ORDER BY au.comment, ' . $deterministicSort;
                    break;
                case '-comment':
                    $orderBy = 'ORDER BY au.comment DESC, ' . $deterministicSort;
                    break;
                case 'faculty_last_name':
                case '+faculty_last_name':
                    $orderBy = 'ORDER BY fp.lastname, fp.firstname, fp.id DESC, ' . $deterministicSort;
                    break;
                case '-faculty_last_name':
                    $orderBy = 'ORDER BY fp.lastname DESC, fp.firstname, fp.id DESC, ' . $deterministicSort;
                    break;
                default:
                    $orderBy = 'ORDER BY ' . $deterministicSort;
                    break;
            }
        } else {
            $orderBy = '';
        }

        $groupBy = '';
        if ($studentListFlag) {
            $selectQuerySubstring = "
                p.id AS student_id,
                p.firstname AS first_name,
                p.lastname AS last_name
            ";
            $groupBy = 'GROUP BY p.id';
        } else if ($isCount) {
            $selectQuerySubstring = "
                COUNT(DISTINCT au.id) AS total_count
            ";
        } else {
            $selectQuerySubstring = "
                DISTINCT au.id AS academic_update_id
            ";
        }

        if ($participationFlag) {
            $participationJoin = "
                INNER JOIN
            org_person_student_year opsy ON opsy.person_id = p.id
            ";
            $participationYearCondition = " AND opsy.org_academic_year_id = :currentAcademicYearId ";
            $participationDeletedAtCheck = " AND opsy.deleted_at IS NULL ";
        } else {
            $participationJoin = "";
            $participationYearCondition = "";
            $participationDeletedAtCheck = "";
        }

        $academicUpdateFilterCriteriaString = '';
        if (($academicUpdateFilterCriteria != null) && !empty($academicUpdateFilterCriteria)) {
            $academicUpdateFilterCriteriaString .= " AND( $academicUpdateFilterCriteria )";
        }

        //WARNING: DO NOT replace person with person_with_risk_intent_denullifier or this will break
        $sql = "SELECT 
                    $selectQuerySubstring
                FROM
                    academic_update au
                        INNER JOIN
                    org_courses oc ON oc.id = au.org_courses_id
                        AND oc.organization_id = au.org_id
                        INNER JOIN
                    org_course_student ocs ON ocs.org_courses_id = oc.id
                        AND ocs.organization_id = au.org_id
                        AND ocs.person_id = au.person_id_student
                        INNER JOIN
                    person p ON p.id = au.person_id_student
                        AND p.organization_id = au.org_id
                        $participationJoin
                         LEFT JOIN 
                     risk_level rl ON (p.risk_level = rl.id
                         OR (rl.risk_text = 'gray'
                         AND p.risk_level IS NULL))
                          LEFT JOIN
                    org_course_faculty ocf ON ocf.org_courses_id = oc.id
                        AND ocf.organization_id = au.org_id
                        AND ocf.person_id = au.person_id_faculty_responded
                        AND ocf.deleted_at IS NULL
                        LEFT JOIN
                    person fp ON fp.id = ocf.person_id
                        AND fp.organization_id = au.org_id
                        AND fp.deleted_at IS NULL
                WHERE
                    au.org_id = :organizationId
                        $participationYearCondition
                        AND oc.org_academic_year_id = :currentAcademicYearId
                        AND au.status = 'closed'
                        AND au.deleted_at IS NULL
                        AND oc.deleted_at IS NULL
                        AND ocs.deleted_at IS NULL
                        AND p.deleted_at IS NULL
                        $participationDeletedAtCheck
                        AND $studentSelectSQL
                        $academicUpdateFilterCriteriaString
                        $groupBy
                        $orderBy
                        $limit";

        $result = $this->executeQueryFetchAll($sql, $parameters);

        if (!$studentListFlag && !$isCount) {
            $result = array_column($result, 'academic_update_id');
        }
        return $result;
    }

    /**
     * Get all academic update report list based on academic update ids
     * Optional Modification of the Academic Update DateTime to Standard datetimes
     *
     * @param array $academicUpdateIds
     * @param int $currentAcademicYearId
     * @param bool $isTimeZoneConversionNeeded
     * @param string $organizationTimeZone - Like 'US/Central'
     * @param string $createdAtDateTimeFormat - Date Format
     * @return array
     * @throws SynapseDatabaseException
     */
    public function getAllAcademicUpdateReportForListedAcademicUpdateIds($academicUpdateIds, $currentAcademicYearId,  $isTimeZoneConversionNeeded = false, $organizationTimeZone = null, $createdAtDateTimeFormat = '%m/%d/%Y')
    {
        $parameters = [
            'academicUpdateIds' => $academicUpdateIds,
            'currentAcademicYearId' => $currentAcademicYearId
        ];
        $parameterTypes = ['academicUpdateIds' => Connection::PARAM_INT_ARRAY];

        if ($isTimeZoneConversionNeeded) {
            $parameters['timeZoneString'] = $organizationTimeZone;
            $parameters['createdAtDateTimeFormat'] = $createdAtDateTimeFormat;
            $createdAtString = " DATE_FORMAT(CONVERT_TZ(au.update_date, 'UTC', :timeZoneString), :createdAtDateTimeFormat) AS created_at, " ;
        } else {
            $createdAtString = ' au.update_date AS created_at, ';
        }

        $sql = "SELECT 
                    pwrid.person_id AS student_id,
                    pwrid.external_id,
                    pwrid.firstname AS student_first_name,
                    pwrid.lastname AS student_last_name,
                    pwrid.username AS email,
                    oc.id AS course_id,
                    CONCAT(oc.subject_code, oc.course_number) AS course_name,
                    fp.id AS faculty_id,
                    fp.firstname AS faculty_first_name,
                    fp.lastname AS faculty_last_name,
                    au.id AS academic_update_id,
                    $createdAtString
                    au.failure_risk_level AS failure_risk,
                    au.grade AS inprogress_grade,
                    au.absence AS absences,
                    CASE aur.update_type
                        WHEN 'adhoc' THEN true
                        ELSE false
                    END AS by_request,
                    au.comment,
                    pem.metadata_value AS class_level,
                    opsy.is_active AS student_status,
                    rl.image_name AS risk_imagename,
                    rl.risk_text,
                    oat.id AS term_id,
                    oat.name AS term_name,
                    CASE
                        WHEN au.is_upload = 1 THEN 'upload'
                        WHEN au.academic_update_request_id IS NOT NULL THEN 'By request'
                        WHEN au.update_type = 'adhoc' THEN 'adhoc'
                    END AS update_type
                FROM
                    academic_update au
                        INNER JOIN
                    org_courses oc ON oc.id = au.org_courses_id
                        AND oc.deleted_at IS NULL
                        INNER JOIN
                    person_with_risk_intent_denullifier pwrid ON pwrid.person_id = au.person_id_student
                        AND pwrid.organization_id = au.org_id
                        INNER JOIN
                    org_person_student_year opsy ON opsy.person_id = pwrid.person_id
                        AND opsy.org_academic_year_id = :currentAcademicYearId
                        LEFT JOIN
                    org_academic_terms oat ON oat.id = oc.org_academic_terms_id
                        AND oat.organization_id = oc.organization_id
                        LEFT JOIN
                    org_course_faculty ocf ON ocf.org_courses_id = oc.id
                        AND ocf.organization_id = au.org_id
                        AND ocf.person_id = au.person_id_faculty_responded
                        AND ocf.deleted_at IS NULL
                        LEFT JOIN
                    risk_level rl ON pwrid.risk_level = rl.id
                        AND rl.deleted_at IS NULL
                        LEFT JOIN
                    person fp ON fp.id = ocf.person_id
                        AND fp.organization_id = au.org_id
                        AND fp.deleted_at IS NULL
                        LEFT JOIN
                    person_ebi_metadata AS pem ON (pem.person_id = pwrid.person_id
                        AND pem.deleted_at IS NULL
                        AND pem.ebi_metadata_id IN (Select 
                            id
                        FROM
                            ebi_metadata
                        WHERE
                            meta_key = 'ClassLevel'))
                        LEFT JOIN
                    academic_update_request aur ON aur.person_id = fp.id
                        AND aur.org_id = au.org_id
                        AND aur.deleted_at IS NULL
                WHERE
                    au.id IN (:academicUpdateIds)
                    AND au.deleted_at IS NULL
                GROUP BY student_id, course_id, faculty_id, au.id
                ORDER BY FIELD(au.id, :academicUpdateIds)";

       $result = $this->executeQueryFetchAll($sql, $parameters, $parameterTypes);

        return $result;
    }
}
